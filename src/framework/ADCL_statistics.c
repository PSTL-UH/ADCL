#include "ADCL_internal.h"

static int adcl_compare ( const void*, const void* );

/* An outlier defines as number of times larger 
   than the minimal value */
int ADCL_OUTLIER_FACTOR=3;

/* Percentage of outliers allowed such that we really 
   treat them as outliers */
int ADCL_OUTLIER_FRACTION=20;

/* what measure shall be used ? */
int ADCL_statistic_method=ADCL_STATISTIC_VOTE;



/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
int ADCL_statistics_filter_timings (ADCL_emethod_req_t *ermethod )
{
    int i, j, k;
    int numoutl, rank;
    TIME_TYPE min;
    int count = ermethod->er_num_emethods;
    ADCL_emethod_t *emethods = ermethod->er_emethods;

    MPI_Comm_rank ( ermethod->er_comm, &rank );
    for (i=0; i < count; i++ ) {
	/* Determine the min  value for method i*/
	for ( min=999999, j=0; j<emethods[i].em_rescount; j++ ) {
	    if ( emethods[i].em_time[j] < min ) {
		min = emethods[i].em_time[j];
	    }
	}

	/* Count how many values are N times larger than the min. */
	for ( numoutl=0, j=0; j<emethods[i].em_rescount; j++ ) {
	    if ( emethods[i].em_time[j] >= (ADCL_OUTLIER_FACTOR * min) ) {
		ADCL_printf("#%d: method %d meas. %d is outlier %lf min %lf\n",
			    rank, i, j, emethods[i].em_time[j], min );
		numoutl++;
	    }
	}
	ADCL_printf("#%d: method %d num. of outliers %d min %lf\n",
		    rank, i, numoutl, min );

	/* 
	** If the percentage of outliers is below a defined maximum,
	** we simply remove them from the list and adapt all counters.
	** If it is above, we can not assume, that they are outliers.
	** They might be generated by the method, e.g. by regularly
	** congesting the network.
	*/
	if ((100*numoutl/emethods[i].em_rescount) < ADCL_OUTLIER_FRACTION ) {
	    for ( k=0, j=0; j<emethods[i].em_rescount; j++ ) {
		if (emethods[i].em_time[j] < (ADCL_OUTLIER_FACTOR * min)){
 		    emethods[i].em_time[k++] = emethods[i].em_time[j];
		}
	    }
	    emethods[i].em_rescount -= numoutl;
	    emethods[i].em_count -= numoutl;
	}
    }
      
    return ADCL_SUCCESS;
}

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/* Determine which method gets how many points */
int ADCL_statistics_determine_votes ( ADCL_emethod_req_t *ermethod )
{
    double sum, *sorted=NULL;
    int i, j, rank, pts;
    ADCL_emethod_t *emethods=ermethod->er_emethods;
    int count=ermethod->er_num_emethods;

    if ( ADCL_STATISTIC_VOTE == ADCL_statistic_method ) {
	MPI_Comm_rank ( ermethod->er_comm, &rank );
	sorted = (double *) malloc ( 2*count*sizeof(double));
	if ( NULL == sorted ) {
	    return ADCL_NO_MEMORY;
	}
	
	for ( i=0; i < count; i++ ) {
	    for ( sum=0, j=0; j< emethods[i].em_rescount; j++ ) {
		sum += emethods[i].em_time[j];
	    }
	    sorted[2*i]     = sum/emethods[i].em_rescount;
	    sorted[(2*i)+1] = emethods[i].em_id;
	}
	
	qsort ( sorted, count, 2*sizeof(double), adcl_compare );
	
	/* Give now the fastest method count-1 pts, the 2nd fastest
	   method count-2 pts, ..., the slowest method 0 pts. */
	for ( pts=count-1, i=0; i< count; i++, pts-- ) {
	    for (j=0; j< count; j++ ) {
		if ( sorted[(2*i)+1] == emethods[j].em_id ) {
		    /*	emethods[j].em_lpts = pts; */
		    emethods[j].em_lpts = count * sorted[0]/sorted[2*i];
		    ADCL_printf("#%d: assigning %lf pts for emethod %d"
				" method %d\n", rank, emethods[j].em_lpts, 
				emethods[j].em_id, emethods[j].em_method->m_id );
		    continue;
		}
	    }
	}
	free ( sorted );
    }
    else if (ADCL_STATISTIC_MAX == ADCL_statistic_method ) {
	for ( i=0; i < count; i++ ) {
	    for ( sum=0, j=0; j< emethods[i].em_rescount; j++ ) {
		sum += emethods[i].em_time[j];
	    }
	    emethods[i].em_lpts = sum/emethods[i].em_rescount;
	}
    }

    return ADCL_SUCCESS;
}

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
int ADCL_statistics_global_max ( ADCL_emethod_req_t *ermethod )
{
    int i, winner=-1;
    double *lpts, *gpts;
    int count = ermethod->er_num_emethods;

    lpts = (double *) malloc ( 2* count * sizeof(double));
    if ( NULL == lpts ) {
	return winner;
    }
    gpts = &(lpts[count]);

    for ( i = 0; i < count; i++ ) {
	lpts[i] = ermethod->er_emethods[i].em_lpts;
    }

    if ( ADCL_STATISTIC_VOTE == ADCL_statistic_method ) {
	int max;

	MPI_Allreduce ( lpts, gpts, count, MPI_DOUBLE, MPI_SUM, ermethod->er_comm);
	for ( winner=0, max=gpts[0], i = 1; i < count; i++ ) {
	    if ( gpts[i] > max ) {
		max    = gpts[i];
		winner = i;
	    }
	}
    }
    else if  ( ADCL_STATISTIC_MAX == ADCL_statistic_method ) {
	int min;

	MPI_Allreduce ( lpts, gpts, count, MPI_DOUBLE, MPI_MAX, ermethod->er_comm);
	for ( winner=0, min=gpts[0], i = 1; i < count; i++ ) {
	    if ( gpts[i] < min ) {
		min = gpts[i];
		winner = i;
	    }
	}
    }

    free ( lpts );
    return winner;
}    

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
static int adcl_compare ( const void *p, const void *q )
{
    double *a, *b;
    
    a = (double *) p;
    b = (double *) q;

    /* simple tests are those where the avg execution times 
       are different */
    if ( a[0] < b[0] ) {
        return (-1);
    }
    if ( a[0] > b[0] ) {
        return (1);
    }

    /* ok, if the avg execution times are the same then we 
       chose the one with the smaller id number. Since these
       are however double values, this should hopefully not
       really happen */
    if ( a[0] == b[0] ) {
        if ( a[1] < b[1] ) {
            return (-1);
        }
        if ( a[1] > b[1] ) {
            return (1);
        }
    }
    return ( 0 );
}
