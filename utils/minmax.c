#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAXLINE 120
struct procinf {
    int nummin;
    int nummax;
    int numoutliers;
};

struct lininf {
    int    req;
    int    method;
    double min;
    double max;
    int    minloc;
    int    maxloc;
};

struct emethod{
    int     em_count;
    int     em_rescount;
    double  *em_time;
    int     *em_poison;
    int     em_num_outliers;
};

int numprocs=-1, numrequests=-1, nummethods=-1, nummeas=-1;
FILE **infd=NULL,  *outfd=NULL;
int deconly=0;
int filter=0;

#define TLINE_INIT(_t) {_t.req=-1; _t.min=9999999999.99; _t.max=0.0; _t.minloc=-1;\
                        _t.maxloc=-1;}
#define TLINE_MIN(_t, _time, _i){ \
           if ( _time < _t.min ) { \
	       _t.min    = _time;  \
	       _t.minloc = _i;}}
#define TLINE_MAX(_t, _time, _i) { \
	    if ( _time > _t.max ) { \
		_t.max = _time;     \
		_t.maxloc =_i;}}
             

void minmax_init (int argc, char ** argv, struct procinf **proc );
void emethods_init ( struct emethod ***emethods);
void filter_timings ( struct emethod **emethods, int outlier_factor, int outlier_fraction );
void minmax_filtered ( struct emethod **em );
void clear_poison_field ( struct emethod **em);

int main (int argc, char **argv )
{
    int i, ret, all_done, no_line, req, method, pos;
    char line[MAXLINE], *basestr, reqstr[50];
    double time;
    struct lininf tline;
    struct procinf *tproc;
    struct emethod **emethods;

    int outlier_factor=3, outlier_fraction=100;

    minmax_init ( argc, argv, &tproc );
    if ( filter ) {
	emethods_init ( &emethods);
    }

    /* Read infile and store the values in the according list */
    TLINE_INIT(tline);
    all_done = 0;
    while ( all_done < numprocs ) {
	for ( i=0; i< numprocs; i++ ) {
	    no_line = 0;
	    while ( !no_line ) {
		ret = fscanf ( infd[i], "%[^\n]\n", line );
		if ( EOF == ret ) {
		    all_done++;
		    break;
		}
		if ( NULL != strstr ( line, "winner is") &&
		     deconly ){
		    goto exit;
		}
		if ( line[0] == '#' ) {
		    /* Skip comment lines */
		    continue;
		}
		no_line = 1;
	    }	    
	    
	    if ( i == 0 ) {
		/*read the parameters of the run */
		basestr = strstr ( line, "request" );
		sscanf ( basestr, "%7s %d", reqstr, &tline.req );
		
		basestr = strstr ( line, "method" );
		sscanf ( basestr, "%6s %d", reqstr, &tline.method );
		
		basestr = strstr ( line, ")" );
		sscanf ( basestr, "%1s %lf\n", reqstr, &time );
	    }
	    else {
		/*read the parameters of the run */
		basestr = strstr ( line, "request" );
		sscanf ( basestr, "%7s %d", reqstr, &req );
		if ( req != tline.req ) {
		    printf("Request mismatch at process %d \n", i);
		}
		
		basestr = strstr ( line, "method" );
		sscanf ( basestr, "%6s %d", reqstr, &method );
		if ( method != tline.method ) {
		    printf ("Method mismatch at process %d\n", i);
		}		

		basestr = strstr ( line, ")" );
		sscanf ( basestr, "%1s %lf\n", reqstr, &time );
	    }		
	    
	    if ( filter ) {
		pos = emethods[i][tline.method].em_rescount;
		emethods[i][tline.method].em_time[pos] = time;
		emethods[i][tline.method].em_rescount++;
	    }

	    TLINE_MIN(tline,time,i);
	    TLINE_MAX(tline,time,i);

	}
	fprintf (outfd, 
		 "%3d %3d %8.4lf %3d %8.4lf %3d\n", 
		 tline.req, 
		 tline.method, 
		 tline.min, 
		 tline.minloc,
		 tline.max, 
		 tline.maxloc );

	tproc[tline.minloc].nummin++;
	tproc[tline.maxloc].nummax++;

	/* Reset the lininf structure */
	TLINE_INIT(tline);
    }

 exit:
    for ( i=0; i< numprocs; i++ ) {
	fprintf(outfd, "Proc %d : num of min. %d num of max %d num of outliers %d\n", i, 
		tproc[i].nummin, tproc[i].nummax, tproc[i].numoutliers );
    }
    

    for ( i=0; i< numprocs; i++ ) {
	fclose ( infd[i]);
    }
    fclose ( outfd );
    free ( tproc );
    free ( infd );

    /* Second step: filter the data as required */
    if ( filter ) {
	filter_timings (emethods, outlier_factor, outlier_fraction);
	minmax_filtered (emethods );
    }

    /*   emethods_finalize (&emethods); */

    return ( 0 );
}


/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
void minmax_init (int argc, char ** argv, struct procinf **proc) 
{
    struct procinf *tproc;
    char inname[50];
    int i;


    if (argc < 5 )
    {
	printf(" Usage : minmax <numprocs> <numrequests> <nummethods> <nummeas>"
	       " <options>\n\n");
	printf("   minmax takes the output files generated by ADCL and \n");
	printf("   determines for each individual measurement the minimal and \n");
	printf("   maximual value across all processes and the according locations\n");
	printf(" Options: \n");
	printf("   <numprocs>   : number of processes \n");
	printf("   <numrequests>: number of requests \n");
	printf("   <nummethods> : number of evaluated implementations \n");
	printf("   <nummeas>    : number of measurements per implementation \n");
	printf("   -deconly     : stop after the decision procedure\n");
	printf("   -filter      : apply the ADCL style filtering \n");
	exit ( 1 ) ;
    }
    
    numprocs    = atoi( argv[1] );
    numrequests = atoi ( argv[2] );
    nummethods  = atoi (argv[3] );
    nummeas     = atoi ( argv[4]);
    
    if ( argc == 6) {
	if (strncmp(argv[5], "-deconly", strlen("-deconly") )== 0 ) {
	    deconly = 1;
	}
	if (strncmp(argv[5], "-filter", strlen("-filter") )== 0 ) {
	    deconly=1;
	    filter = 1;
	}

    }

    if ( argc == 7) {
	if (strncmp(argv[5], "-filter", strlen("-filter") )== 0 ) {
	    deconly=1;
	    filter = 1;
	}
    }



    tproc = (struct procinf *) calloc (1, numprocs * sizeof(struct procinf));
    if ( NULL == tproc ) {
	exit ( -1 );
    }
    *proc = tproc;

    infd = (FILE **) malloc ( numprocs * sizeof(FILE *) );
    if ( NULL == infd ) {
	exit (-1);
    }

    outfd = fopen ("minmax.out", "w");
    if ( NULL == outfd ) {
	exit ( -1 );
    }

    for ( i = 0; i < numprocs; i++ ) {
	sprintf( inname, "%d.out", i);
	infd[i] = fopen ( inname, "r" );
    }	

    return;
}
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
void emethods_init (  struct emethod *** emethods )
{
     struct emethod **em=NULL;
    int i, j;
    
    em = ( struct emethod **) malloc ( numprocs * sizeof ( struct emethod *));
    if ( NULL == em ) {
	exit (-1);
    }

    for ( i=0; i< numprocs; i++ ) {
	em[i] = ( struct emethod *) calloc ( 1, nummethods * sizeof(struct emethod));
	if  ( NULL == em[i] ) {
	    exit (-1);
	}
	
	for (j=0; j< nummethods; j++ ) {
	    em[i][j].em_time = (double *) calloc (1, nummeas * sizeof(double));
	    if ( NULL == em[i][j].em_time ) {
		exit (-1);
	    }
	    em[i][j].em_poison = (int *) calloc (1, nummeas * sizeof(int));
	    if ( NULL == em[i][j].em_poison ) {
		exit (-1);
	    }
	    em[i][j].em_count    = nummeas;
	}
    }

    *emethods = em;
    return;
}
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
void filter_timings ( struct emethod **emethods, int outlier_factor,
		     int outlier_fraction )
{
    int i, j, k;
    int numoutl;
    double min;

    for (i=0; i < numprocs; i++ ) {
	for ( j=0; j< nummethods; j++ ) {
	    /* Determine the min  value for method [i][j]*/
	    for ( min=999999, k=0; k<emethods[i][j].em_rescount; k++ ) {
		if ( emethods[i][j].em_time[k] < min ) {
		    min = emethods[i][j].em_time[k];
		}
	    }

	    /* Count how many values are N times larger than the min. */
	    for ( numoutl=0, k=0; k<emethods[i][j].em_rescount; k++ ) {
		if ( emethods[i][j].em_time[k] >= (outlier_factor * min) ) {
		    printf("#%d: method %d meas. %d is outlier %lf min %lf\n",
			   i, j, k,  emethods[i][j].em_time[j], min );
		    numoutl++;
		}
	    }
	    printf("#%d: method %d num. of outliers %d min %lf\n",
		   i, j, numoutl, min );

	    if ((100*numoutl/emethods[i][j].em_rescount) < outlier_fraction ) {
		for ( k=0; k<emethods[i][j].em_rescount; k++ ) {
		    if ( emethods[i][j].em_time[k] >= (outlier_factor * min) ) {
			emethods[i][j].em_poison[k] = 1;
		    }
		}
	    }
	}
    }

    return;
}

void minmax_filtered ( struct emethod **em )
{
    int i, j, k;
    FILE *outf;
    struct lininf tline;

    outf = fopen("minmax-filtered.out", "w");
    if ( NULL == outf ) {
	exit (-1);
    }

    for (j=0; j< nummethods; j++ ) {
	for ( k=0; k<nummeas; k++ ) {
	    TLINE_INIT(tline);
	    for (i=0; i< numprocs; i++ ) {
		if ( !em[i][j].em_poison[k] ) {
		    TLINE_MIN(tline, em[i][j].em_time[k], i);
		    TLINE_MAX(tline, em[i][j].em_time[k], i);
		}
		else {
		    em[i][j].em_num_outliers++;
		}
	    }
	    fprintf (outf, "%3d %8.4lf %3d %8.4lf %3d\n", 
		     j, tline.min, tline.minloc, tline.max, 
		     tline.maxloc );
	    
	}
    }
    fclose (outf);

    /* Dump the outlier information per method */    

    outf = fopen ("procinfo-filtered.out", "w");
    if ( NULL == outf ) {
	exit (-1);
    }

    for ( i=0; i< numprocs; i++ ) {
	fprintf(outf, "%d: ", i);
	for ( j=0; j< nummethods; j++ ) {
	    fprintf(outf, " %d ", em[i][j].em_num_outliers);
	}
	fprintf(outf, "\n");
    }

    fclose (outf);
    return;
}

void clear_poison_field ( struct emethod **em)
{
    int i, j, k;

    for ( i=0; i<numprocs; i++ ) {
	for (j=0; j< nummethods; j++ ) {
	    for ( k=0; k<nummeas; k++ ) {
		em[i][j].em_poison[k] = 0;
	    }
	}
    }

    return;
}

